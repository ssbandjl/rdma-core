原路径: https://github.com/linux-rdma/rdma-core.git
GIT仓库: https://github.com/ssbandjl/rdma-core.git

intel rdma ref: https://blog.csdn.net/bandaoyu/article/details/116203690


fork支持:
enum ibv_fork_status ibv_is_fork_initialized(void)
  get_copy_on_fork


int rdma_listen(struct rdma_cm_id *id, int backlog)
  UCMA_CMD_LISTEN


rdma_create_qp_ex


rdma_create_id -> librdmacm/cma.c


通过索引, 将事件(枚举类型)转为事件说明(字符串)
const char *ibv_event_type_str(enum ibv_event_type event)
    static const char *const event_type_str[]
        [IBV_EVENT_CQ_ERR]		= "CQ error",
    return event_type_str[event]        


.create_qp_ex = mlx5_create_qp_ex,
    static struct ibv_qp *create_q
        ibv_cmd_create_qp_ex -> Move QP create and destroy commands to ioctl




reg mem:
struct ibv_mr *ibv_reg_mr
__ibv_reg_mr
enum ib_uverbs_access_flags
IB_UVERBS_ACCESS_OPTIONAL_RANGE
ibv_reg_mr_iova2 -> verbs：宽松排序内存区域，添加一个标志以允许创建宽松排序内存区域。 通过此类 MR 的访问可以通过允许系统对某些访问重新排序来提高性能。 由于宽松排序是一种优化，因此不支持它的驱动程序可以简单地忽略它。 可选的 MR 访问位范围是根据内核匹配部分定义的，其第一个条目将为 IBV_ACCESS_RELAXED_ORDERING。 如果应用程序使用可选范围中的一位，则库会将其屏蔽掉，以防内核不支持“MR 可选模式”。
    reg_mr -> mlx5_vfio_reg_mr
    .reg_mr	       = mlx5_reg_mr,
        ...
        execute_cmd_write(pd->context, IB_USER_VERBS_CMD_REG_MR, cmd, -> ib_uverbs_reg_mr



split and join cmd:
IB_USER_VERBS_CMD_




intel irdma:
providers/irdma/umain.c
irdma_device_alloc
static const struct verbs_device_ops irdma_udev_ops = {
	.alloc_context = irdma_ualloc_context,
	.alloc_device = irdma_device_alloc,
	.match_max_abi_version = IRDMA_MAX_ABI_VERSION,
	.match_min_abi_version = IRDMA_MIN_ABI_VERSION,
	.match_table = hca_table,
	.name = "irdma",
	.uninit_device = irdma_uninit_device,
};



api:
verbs.c
.alloc_pd 

ibv_post_send
	qp->context->ops.post_send(qp, wr, bad_wr)
	.post_send =  xxx

static const struct verbs_context_ops irdma_uctx_ops = {
	.alloc_mw = irdma_ualloc_mw,
	.alloc_pd = irdma_ualloc_pd,
	.attach_mcast = irdma_uattach_mcast,
	.bind_mw = irdma_ubind_mw,
	.cq_event = irdma_cq_event,
	.create_ah = irdma_ucreate_ah,
	.create_cq = irdma_ucreate_cq,
	.create_cq_ex = irdma_ucreate_cq_ex,
	.create_qp = irdma_ucreate_qp,
	.dealloc_mw = irdma_udealloc_mw,
	.dealloc_pd = irdma_ufree_pd,
	.dereg_mr = irdma_udereg_mr,
	.destroy_ah = irdma_udestroy_ah,
	.destroy_cq = irdma_udestroy_cq,
	.destroy_qp = irdma_udestroy_qp,
	.detach_mcast = irdma_udetach_mcast,
	.modify_qp = irdma_umodify_qp,
	.poll_cq = irdma_upoll_cq,
	.post_recv = irdma_upost_recv,
	.post_send = irdma_upost_send,
	.query_device_ex = irdma_uquery_device_ex,
	.query_port = irdma_uquery_port,
	.query_qp = irdma_uquery_qp,
	.reg_dmabuf_mr = irdma_ureg_mr_dmabuf,
	.reg_mr = irdma_ureg_mr,
	.rereg_mr = irdma_urereg_mr,
	.req_notify_cq = irdma_uarm_cq,
	.resize_cq = irdma_uresize_cq,
	.free_context = irdma_ufree_context,
};



enum ib_uverbs_write_cmds {
	IB_USER_VERBS_CMD_GET_CONTEXT,
	IB_USER_VERBS_CMD_QUERY_DEVICE,
	IB_USER_VERBS_CMD_QUERY_PORT,
	IB_USER_VERBS_CMD_ALLOC_PD,
	IB_USER_VERBS_CMD_DEALLOC_PD,
	IB_USER_VERBS_CMD_CREATE_AH,
	IB_USER_VERBS_CMD_MODIFY_AH,
	IB_USER_VERBS_CMD_QUERY_AH,
	IB_USER_VERBS_CMD_DESTROY_AH,
	IB_USER_VERBS_CMD_REG_MR,
	IB_USER_VERBS_CMD_REG_SMR,
	IB_USER_VERBS_CMD_REREG_MR,
	IB_USER_VERBS_CMD_QUERY_MR,
	IB_USER_VERBS_CMD_DEREG_MR,
	IB_USER_VERBS_CMD_ALLOC_MW,
	IB_USER_VERBS_CMD_BIND_MW,
	IB_USER_VERBS_CMD_DEALLOC_MW,
	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL,
	IB_USER_VERBS_CMD_CREATE_CQ,
	IB_USER_VERBS_CMD_RESIZE_CQ,
	IB_USER_VERBS_CMD_DESTROY_CQ,
	IB_USER_VERBS_CMD_POLL_CQ,
	IB_USER_VERBS_CMD_PEEK_CQ,
	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ,
	IB_USER_VERBS_CMD_CREATE_QP,
	IB_USER_VERBS_CMD_QUERY_QP,
	IB_USER_VERBS_CMD_MODIFY_QP,
	IB_USER_VERBS_CMD_DESTROY_QP,
	IB_USER_VERBS_CMD_POST_SEND,
	IB_USER_VERBS_CMD_POST_RECV,
	IB_USER_VERBS_CMD_ATTACH_MCAST,
	IB_USER_VERBS_CMD_DETACH_MCAST,
	IB_USER_VERBS_CMD_CREATE_SRQ,
	IB_USER_VERBS_CMD_MODIFY_SRQ,
	IB_USER_VERBS_CMD_QUERY_SRQ,
	IB_USER_VERBS_CMD_DESTROY_SRQ,
	IB_USER_VERBS_CMD_POST_SRQ_RECV,
	IB_USER_VERBS_CMD_OPEN_XRCD,
	IB_USER_VERBS_CMD_CLOSE_XRCD,
	IB_USER_VERBS_CMD_CREATE_XSRQ,
	IB_USER_VERBS_CMD_OPEN_QP,
};




DECLARE_CMD(IB_USER_VERBS_CMD_ALLOC_PD, ibv_alloc_pd, ib_uverbs_alloc_pd);
ib_uverbs_alloc_pd


irdma_ualloc_pd
	ibv_cmd_alloc_pd -> 分配保护域,返回其指针
		execute_cmd_write IB_USER_VERBS_CMD_ALLOC_PD -> #define execute_cmd_write(ctx, enum, cmd, cmd_size, resp, resp_size)
			ioctl_ptr_to_u64
			_execute_cmd_write
				cmd + check_type(cmd, IBV_ABI_REQ(enum) *)
				return ioctl_write -> ioctl_write 比 write 更安全
					fill_attr_const_in -> #define fill_attr_const_in(cmd, attr_id, _data)
					return execute_ioctl(ctx, cmdb) -> 动词：为 kabi ioctl 添加基本基础设施支持 这些宏和辅助函数可帮助从调用命令构建 ioctl 消息。 该方案使用属性缓冲区的链接列表，其思想是驱动程序和核心堆栈帧将在堆栈上分配这些缓冲区。 ioctl 包装器将所有缓冲区集中到一个线性数组中，并将其传递给内核，然后将答案分散回它们的来源处。 提供了一系列“填充”帮助程序，它们反映了内核中的提取帮助程序。 每个属性都应与与内核中的内容相匹配的填充帮助程序类型一起使用
						prepare_attrs
						ioctl(context->cmd_fd, RDMA_VERBS_IOCTL, &cmd->hdr) -> 用户态 -> 内核态
						finalize_attrs

				


verbs_init_context
    context_ex->priv->use_ioctl_write = has_ioctl_write(context);

verbs_init_and_alloc_context


irdma_ualloc_context

.alloc_context = irdma_ualloc_context

ibv_open_device
verbs_open_device


irdma_upost_send
IRDMA_RING_MORE_WORK
while (ib_wr)
	case IBV_WR_SEND
		irdma_uk_inline_send or
		irdma_uk_send
	case IBV_WR_RDMA_WRITE
		irdma_uk_inline_rdma_write or
		irdma_uk_rdma_write




libibverbs/examples/CMakeLists.txt
rdma_executable(ibv_rc_pingpong rc_pingpong.c)
libibverbs/examples/rc_pingpong.c -> main
ibv_get_device_list
pp_init_ctx
pp_post_recv
ibv_req_notify_cq
pp_get_port_info
pp_client_exch_dest or
pp_server_exch_dest
pp_connect_ctx
ibv_memcpy_to_dm
pp_post_send
pp_cq
ibv_start_poll


rdma_executable(ibv_devices device_list.c)
rdma_executable(ibv_devinfo devinfo.c)
	print_hca_cap
		ibv_open_device
		ibv_query_device_ex
		ibv_read_sysfs_file
		ibv_query_port
		print_all_port_gids
			ibv_query_gid
			ibv_query_gid_type



irdma_ucreate_qp


buid, make:
export ROOT=$(dirname $PWD)
export BUILD_DIR=$ROOT/build
export BIN=$BUILD_DIR/bin
export LIB=$BUILD_DIR/lib
export PYTHONPATH=$BUILD_DIR/python:$BUILD_DIR/python/pyverbs
export LD_LIBRARY_PATH=$LIB
export PATH=$BIN:$PATH
. ~/rdma-core-env.sh
which rping



bash build.sh
	CMAKE
	NINJA
	cmake -DIN_PLACE=1 ..
CMakeLists.txt



cmake参数说明:
传递给 cmake 的常见选项有：
  -DIN_PLACE=1
      将构建配置为从构建目录运行，这会产生一些结果
      那是不可安装的。
  -DCMAKE_EXPORT_COMPILE_COMMANDS=1
      为 clang 工具编写一个compile_commands.json 文件
  -DCMAKE_BUILD_TYPE=RelWithDebInfo
      更改优化级别，调试禁用优化，
      发布适用于打包者
  -DENABLE_VALGRIND=0（默认启用）
      禁用 valgrind 符号，这对性能有微小的积极影响
  -DENABLE_RESOLVE_NEIGH=0（默认启用）
      不要链接到 libnl，也不在内部解析以太网的邻居，
      并且不要构建 iwpmd。
  -DENABLE_STATIC=1（默认禁用）
      生成静态库以及常用的共享库。
  -DVERBS_PROVIDER_DIR='' （默认 /usr/lib.../libibverbs）
      使用标准系统库中提供者的历史搜索路径。
  -DNO_COMPAT_SYMS=1（默认禁用）
      不要在共享中生成向后兼容符号
      图书馆。 如果使用动态链接器，这可能是必要的
      不支持符号版本，例如uclibc。
  -DIOCTL_MODE=写入（默认两者）
      禁用新的 kABI ioctl() 支持并仅支持旧写入
      小路。 也可以是“ioctl”来禁用回退写入。
  -DIBACM_SERVER_MODE_DEFAULT（默认unix）
      选择客户端连接到此服务器的方式：
      open) 允许来自任何 TCP 客户端（内部或外部）的传入连接。
      循环）将 server_port 的传入连接限制为 127.0.0.1。
      unix) 使用 unix 域套接字，因此限制对同一台机器的服务。
  -DIBACM_ACME_PLUS_KERNEL_ONLY_DEFAULT（默认0）
      如果非零，则限制对内核或 ib_acme 实用程序的传入请求
      （即不服务 librdmacm 请求）
  -DPYTHON_EXECUTABLE
      覆盖 python 的自动检测以使用特定的
      可执行的。 这可以用来强制构建在 a 上使用 python2
      安装了 python3 的系统。 否则自动构建
      如果可用的话，更喜欢 python3。
   -DNO_PYVERBS=1（默认，构建 pyverbs）
      调用 cython 来构建 pyverbs。 通常您将使用此选项运行
      放
   -DENABLE_IBDIAGS_COMPAT=True（默认False）
      包括过时的脚本。 这些脚本被 C 程序替换为
      现在是一个不同的界面。
   -DNO_MAN_PAGES=1（默认 0，构建/安装手册页）
      禁用手册页。 允许构建和安装 rdma-core
      （没有手册页）当既不是 pandoc/rst2man 也不是 pandoc-prebuilt 时
      目录可用。
   -DENABLE_LTTNG（默认，不支持跟踪）
      启用 LTTng 跟踪。




ibdump
src/MLNX_OFED_SRC-5.8-3.0.7.0/SOURCES/ibdump-6.0.0/ibdump
gdb --args ./ibdump -d mlx5_0 -w test.pcap

src/MLNX_OFED_SRC-5.8-3.0.7.0/SOURCES/ibdump-6.0.0/ibdump.c -> main
struct config_t config
resources_create
    ibv_alloc_pd
    ibv_create_cq
    res->entry_size = 1024*4
    tmp = (char*)(((u_int64_t)tmp + 0x1000) & ~0xfff)
    ibv_reg_mr
    qp_init_attr.qp_type    = IBV_QPT_RAW_PACKET
    ibv_create_qp
fw_version_less_than
set_sw_sniffer
    fourth_gen_set_sw_sniffer
        flow_attr.type = IBV_FLOW_ATTR_SNIFFER;
        ibv_create_flow(res->qp, &flow_attr) -> .create_flow -> SET_OP2(vctx -> , ibv_create_flow, create_flow) -> mlx5_create_flow
            get_flow_mcounters
            ibv_cmd_create_flow
                ib_spec_to_kern_spec
                execute_cmd_write_ex_full IB_USER_VERBS_EX_CMD_CREATE_FLOW
set_pcap_header
    fwrite(&hdr, sizeof(hdr), 1, fh)
poll_completion
    ibv_poll_cq

	